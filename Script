// Global Variables
var lastCompatibleVersion = 2.031;
if (Game.version > lastCompatibleVersion) {
  console.log(
    "WARNING: The Cookie Clicker version is newer than this version of Frozen Cookies."
  );
  console.log(
    "This version of Frozen Cookies has only been tested through Cookie Clicker version " +
      lastCompatibleVersion
  );
  console.log(
    "There may be incompatibilities, undesirable effects, bugs, shifts in reality, immoral behavior, and who knows what else."
  );
}

var scriptElement =
  document.getElementById("frozenCookieScript") !== null
    ? document.getElementById("frozenCookieScript")
    : document.getElementById("modscript_frozen_cookies");
var baseUrl =  scriptElement !== null
    ? scriptElement.getAttribute("src").replace(/\/frozen_cookies\.js$/, "")
    : "https://icehawk78.github.io/FrozenCookies/";
var FrozenCookies = {
  baseUrl: baseUrl,
  branch: "Main-",
  version: "2.0.0",
};

// Load external libraries
var script_list = [
  "https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js",
  "https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/themes/smoothness/jquery-ui.css",
  "https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js",
  "https://cdnjs.cloudflare.com/ajax/libs/jcanvas/20.1.1/min/jcanvas.min.js",
  "https://cdnjs.cloudflare.com/ajax/libs/jqPlot/1.0.9/jquery.jqplot.min.js",
  "https://cdnjs.cloudflare.com/ajax/libs/jqPlot/1.0.9/jquery.jqplot.min.css",
  "https://cdnjs.cloudflare.com/ajax/libs/jqPlot/1.0.9/plugins/jqplot.canvasTextRenderer.min.js",
  "https://cdnjs.cloudflare.com/ajax/libs/jqPlot/1.0.9/plugins/jqplot.canvasAxisLabelRenderer.min.js",
  "https://cdnjs.cloudflare.com/ajax/libs/jqPlot/1.0.9/plugins/jqplot.canvasAxisTickRenderer.min.js",
  "https://cdnjs.cloudflare.com/ajax/libs/jqPlot/1.0.9/plugins/jqplot.trendline.min.js",
  "https://cdnjs.cloudflare.com/ajax/libs/jqPlot/1.0.9/plugins/jqplot.highlighter.min.js",
  "https://cdnjs.cloudflare.com/ajax/libs/jqPlot/1.0.9/plugins/jqplot.logAxisRenderer.min.js",
  "https://cdnjs.cloudflare.com/ajax/libs/jqPlot/1.0.9/plugins/jqplot.cursor.min.js",
  FrozenCookies.baseUrl + "/fc_preferences.js",
  FrozenCookies.baseUrl + "/cc_upgrade_prerequisites.js",
  FrozenCookies.baseUrl + "/fc_main.js",
  FrozenCookies.baseUrl + "/fc_button.js",
  FrozenCookies.baseUrl + "/fc_spellpredict.js",
  FrozenCookies.baseUrl + "/fc_infobox.js",
];

FrozenCookies.loadInterval = setInterval(function () {
  if (Game && Game.ready) {
    clearInterval(FrozenCookies.loadInterval);
    FrozenCookies.loadInterval = 0;
    fcInit();
  }
}, 1000);

function loadScript(id) {
  if (id >= script_list.length) {
    registerMod("frozen_cookies"); // when the mod is registered, the save data is passed in the load function
  } else {
    var url = script_list[id];
    if (/\.js$/.exec(url)) {
      $.getScript(url, function () {
        loadScript(id + 1);
      });
    } else if (/\.css$/.exec(url)) {
      $("<link>")
        .attr({
          rel: "stylesheet",
          type: "text/css",
          href: url,
        })
        .appendTo($("head"));
      loadScript(id + 1);
    } else {
      console.log("Error loading script: " + url);
      loadScript(id + 1);
    }
  }
}

function fcInit() {
  var jquery = document.createElement("script");
  jquery.setAttribute("type", "text/javascript");
  jquery.setAttribute("src", "https://code.jquery.com/jquery-3.6.0.min.js");
  jquery.setAttribute(
    "integrity",
    "sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4="
  );
  jquery.setAttribute("crossorigin", "anonymous");
  jquery.onload = function () {
    loadScript(0);
  };
  document.head.appendChild(jquery);
}
if(Horticookie === undefined) var Horticookie = {};
if(typeof CCSE == 'undefined') Game.LoadMod('https://klattmose.github.io/CookieClicker/' + (0 ? 'Beta/' : '') + 'CCSE.js');
Horticookie.name = 'Horticookie';
Horticookie.version = '4.2';
Horticookie.GameVersion = '2.052';

Horticookie.launch = function(){
	Horticookie.init = function(){
		Horticookie.isLoaded = 1;
		Horticookie.Backup = {};
		Horticookie.initCodes();
		Horticookie.setPercentagePrecision(4);
		Horticookie.plantStatus = {};
		Horticookie.unlockables = {};
		Horticookie.unlockableCount = 0;
		
		Horticookie.restoreDefaultConfig();
		
		
		Horticookie.ReplaceNativeGarden();
		Horticookie.ReplaceMainGame();
		
		Game.registerHook('draw', Horticookie.draw);
		
		
		//***********************************
		//    Post-Load Hooks 
		//    To support other mods interfacing with this one
		//***********************************
		if(Horticookie.postloadHooks) {
			for(var i = 0; i < Horticookie.postloadHooks.length; ++i) {
				(Horticookie.postloadHooks[i])();
			}
		}
		
		if (Game.prefs.popups) Game.Popup('Horticookie loaded!');
		else Game.Notify('Horticookie loaded!', '', '', 1, 1);
	}

	Horticookie.initWithGarden = function(M){
		Horticookie.M = M;
		Horticookie.buildMutationMap();
		Horticookie.buildUpgradesMap();
		Horticookie.backupPlants();
		
		var gpl = M.plotLimits[M.plotLimits.length - 1];
		Horticookie.maxPlotWidth = gpl[2] - gpl[0];
		Horticookie.maxPlotHeight = gpl[3] - gpl[1];
		
		Horticookie.nextTickProbabilities = [];
		Horticookie.nextTickProbabilities.length = Horticookie.maxPlotHeight;
		for(var y = 0; y < Horticookie.maxPlotHeight; ++y) {
			var tmp = [];
			tmp.length = Horticookie.maxPlotWidth;
			for(var x = 0; x < tmp.length; ++x) {
				tmp[x] = {empty: 1, immature: {}, mature: {}};
			}
			Horticookie.nextTickProbabilities[y] = tmp;
		}
		
		for(var prefName in Horticookie.config) Horticookie.applyPref(prefName);
		
		Horticookie.recalcTileStatus();
		Horticookie.recalcPlantStatus();
		Horticookie.recalcUnlockables();
	}


	//***********************************
	//    Config functions
	//***********************************
	Horticookie.defaultConfig = function(){
		return {
			ahNew:0,
			ahJuicy:0,
			ahUpgrade:0
		}
	}

	Horticookie.togglePref = function(prefName, button, on, off, invert){
		if (Horticookie.config[prefName]){
			l(button).removeAttribute('checked');
			l(button + '_label').innerHTML = off;
			Horticookie.config[prefName] = 0;
		}else{
			l(button).setAttribute('checked','checked')
			l(button + '_label').innerHTML = on;
			Horticookie.config[prefName] = 1;
		}
		
		if(Game.Objects['Farm'].minigameLoaded) Horticookie.applyPref(prefName);
		
	}

	Horticookie.applyPref = function(prefName){
		var M = Horticookie.M;
		switch(prefName){
			case 'allImmortal':
				for(var key in M.plants){
					if(Horticookie.Backup.plants[key].immortal){} // Do nothing
					else{
						if(Horticookie.config[prefName]){
							if(!M.plants[key].immortal){
								M.plants[key].immortal = 1;
								M.plants[key].detailsStr = (M.plants[key].detailsStr ? M.plants[key].detailsStr + ', i' : 'I') + 'mmortal';
							}
						}
						else{
							M.plants[key].detailsStr = Horticookie.Backup.plants[key].detailsStr;
							delete M.plants[key].immortal;
						}
					}
				}
				Horticookie.computeEffs();
				break;
		}
	}

	Horticookie.save = function(){
		return JSON.stringify(Horticookie.config);
	}

	Horticookie.load = function(str){
		var config = JSON.parse(str);
		Horticookie.config.ahNew = config.ahNew ? 1 : 0;
		Horticookie.config.ahJuicy = config.ahJuicy ? 1 : 0;
		Horticookie.config.ahUpgrade = config.ahUpgrade ? 1 : 0;
		
		if(Game.Objects["Farm"].minigameLoaded) for(var prefName in Horticookie.config) Horticookie.applyPref(prefName);
	}

	Horticookie.restoreDefaultConfig = function(){
		Horticookie.config = Horticookie.defaultConfig();
	}


	//***********************************
	//    Horticookie functions
	//***********************************
	Horticookie.getMenuString = function(){
		let m = CCSE.MenuHelper;
		let baseDir = 'https://klattmose.github.io/CookieClicker/';
		
		var str = m.Header("Autoharvest");
		str += '<div class="listing">' + m.CheckBox(Horticookie.config, 'ahNew', 'ahNewButton', '', '', 'Horticookie.togglePref') + '<label>Autoharvest mature plants that you don\'t have the seeds for.</label></div>';
		str += '<div class="listing">' + m.CheckBox(Horticookie.config, 'ahJuicy', 'ahJuicyButton', '', '', 'Horticookie.togglePref') + '<label>Autoharvest mature Juicy Queenbeets.</label></div>';
		str += '<div class="listing">' + m.CheckBox(Horticookie.config, 'ahUpgrade', 'ahUpgradeButton', '', '', 'Horticookie.togglePref') + '<label>Autoharvest plants that may unlock an upgrade.</label></div>';
		//str += '<div class="listing"><small>The Immortalize option has been split off into its own mod: <a href="' + baseDir + 'ImmortalGarden.js" target="_blank">Immortal Garden</a> (<a href="https://steamcommunity.com/sharedfiles/filedetails/?id=2685525527" target="_blank">Steam</a>).</small></div>';
		//str += '<div class="listing"><small>The Accelerated Garden option has been split off into its own mod: <a href="' + baseDir + 'PredictablePlantGrowth.js" target="_blank">Predictable Plant Growth</a> (<a href="https://steamcommunity.com/sharedfiles/filedetails/?id=2685527807" target="_blank">Steam</a>).</small></div>';
		
		return str;
	}

	Horticookie.initCodes = function(){
		Horticookie.recipeCodes = {};
		Horticookie.statusCodes = {};
		
		Horticookie.recipeCodes.NORMAL = 1;
		Horticookie.recipeCodes.WEED = 2;
		Horticookie.recipeCodes.CREATED_ON_KILL = 3;
		
		Horticookie.statusCodes.MAYGROW = 1;
		Horticookie.statusCodes.PREMATURE = 2;
		Horticookie.statusCodes.MATURE = 3;
		Horticookie.statusCodes.DANGER = 4;
		Horticookie.statusCodes.UNLOCKED = 9;
	}

	Horticookie.formatPercentage = function(value) {
		if(!Horticookie.percentagePrecision) {
			return value * 100 + '%';
		} else {
			var sign = (value < 0 ? '-' : '');
			value = Math.abs(value);
			if(value < Horticookie.minPercentage) {
				if(sign) {
					return '-' + Horticookie.minPercentageStr + 'to 0%';
				} else {
					return '<' + Horticookie.minPercentageStr;
				}
			} else {
				// Decided on floor instead of round, it is more similar to the expectations
				value = Math.round(value * 100 * Horticookie.percentagePow10);
				var low = value % Horticookie.percentagePow10;
				var low_digits = Horticookie.percentagePrecision;
				while(low > 0 && low % 10 === 0) {
					low /= 10;
					low_digits -= 1;
				}
				if(low) {
					low = '' + low;
					while(low.length < low_digits) {
						low = '0' + low;
					}
					low = '.' + low;
				} else {
					low = '';
				}
				var high = Math.floor(value / Horticookie.percentagePow10);
				return sign + high + low + '%';
			}
		}
	}

	Horticookie.calcProbAgingGT = function(N, ageTick, ageTickR, ageBoost) {
		if(N % 1 != 0) {
			throw "In calcProbAgingGT, N must be an integer, got " + N;
		}
		if(N <= 0) {
			return 1;
		}
		ageTick *= ageBoost;
		ageTickR *= ageBoost;
		var p1 = 0;
		var p2 = 0;
		var p3 = 0;
		if(ageTickR > 0) {
			// Probability that ageTick + ageTickR * Math.random() will be less than N - 1
			p1 = (N - 1 - ageTick) / ageTickR;
			p1 = Math.min(Math.max(p1, 0), 1);
			
			// Probability that ageTick + ageTickR * Math.random() will be greater than N
			p2 = (ageTickR - N + ageTick) / ageTickR;
			p2 = Math.min(Math.max(p2, 0), 1);
		} else {
			p1 = (ageTick < N - 1 ? 1 : 0);
			p2 = (ageTick >= N ? 1 : 0);
		}

		if(p1 + p2 < 1) {
			/*
			 * Probability that if ageTick + ageTickR * Math.random() is between N - 1 and N,
			 * it will be rounded to N. I hope my analysis of the probability disribution was
			 * correct.
			 */
			 var a = (ageTick < N - 1 ? 0 : ageTick % 1);
			 var b = (ageTick + ageTickR < N ? ageTickR % 1 : 1 - a);
			 p3 = (1 - p1 - p2) * (a + b / 2);
		}
		
		return p2 + p3;
	}

	Horticookie.setPercentagePrecision = function(precision) {
		if(precision < 0) {
			throw "In setPercentagePrecision: precision must be >= 0, got " + precision;
		} else {
			Horticookie.percentagePrecision = precision;
			if(!precision) {
				Horticookie.minPercentage = null;
				Horticookie.minPercentageStr = null;
				Horticookie.percentagePow10 = null;
		   } else {
				Horticookie.minPercentage = Math.pow(10, -precision - 2);
				Horticookie.minPercentageStr = '' + Math.pow(10, -precision) + '%';
				Horticookie.percentagePow10 = Math.pow(10, precision);
		   }       
		}
	}

	Horticookie.buildMutationMap = function(){
		var M = Horticookie.M;
		var getMuts = M.getMuts.toString();
		Horticookie.mutationsMap = [];
		
		
		//***********************************
		//    Nonstandard recipes go first
		//***********************************
		Horticookie.mutationsMap.push({type:Horticookie.recipeCodes.WEED, product:['meddleweed', 0.002]});
		Horticookie.mutationsMap.push({type:Horticookie.recipeCodes.CREATED_ON_KILL, prereq:'meddleweed', product:['brownMold', 0.1]});
		Horticookie.mutationsMap.push({type:Horticookie.recipeCodes.CREATED_ON_KILL, prereq:'meddleweed', product:['crumbspore', 0.1]});
		
		
		//***********************************
		//    Some functions that I want to put here instead of elsewhere
		//***********************************
		function newMut(source){return {source:source, type:Horticookie.recipeCodes.NORMAL, neighs:[], neighsM:[], product:[]};}
		function parsePredecessors(mut){
			var pres = mut.source.replace(/neighs/g, "").split(" && ");
			for(var i = 0; i < pres.length; i++){
				var mature = pres[i].substring(0, 1) == "M";
				var gt = pres[i].indexOf(">") >= 0;
				var gte = pres[i].indexOf(">=") >= 0;
				var lt = pres[i].indexOf("<") >= 0;
				var lte = pres[i].indexOf("<=") >= 0;
				
				var isMax = false;
				var digit = eval(pres[i].substring(pres[i].length - 1, pres[i].length));
				
				if(gte)     {isMax = false;}
				else if(gt) {isMax = false; digit++;}
				else if(lte){isMax = true; digit++;}
				else if(lt) {isMax = true;}
				
				var plant = eval(pres[i].substring(pres[i].indexOf("[") + 1, pres[i].indexOf("]")));
				
				if(mature) mut.neighsM.push({plant:plant, isMax:isMax, count:digit});
				else mut.neighs.push({plant:plant, isMax:isMax, count:digit});
			}
		}
		
		getMuts = getMuts.replace(/\t/g,'');
		var arr = getMuts.split("\n");
		
		for(var i = 0; i < arr.length; i++){
			var line = arr[i];
			
			if(line.substring(0, 4) == 'if ('){
				var lineMuts = [];
				var pos = 0;
				
				do{
					pos = line.indexOf('(neigh', pos) + 1;
					var temp = line.substring(pos, line.indexOf(')', pos));
					lineMuts.push(newMut(temp));
					
					parsePredecessors(lineMuts[lineMuts.length - 1]);
					
					pos = line.indexOf('||', pos);
				}while(pos > 0)
				
				pos = line.indexOf('muts.push(') + 'muts.push(['.length;
				var product = line.substring(pos, line.indexOf(')', pos) - 1).split('],[');
				
				for(var j = 0; j < lineMuts.length; j++){
					for(var k = 0; k < product.length; k++){
						var mut = newMut();
						mut.neighs = lineMuts[j].neighs;
						mut.neighsM = lineMuts[j].neighsM;
						mut.product = product[k].split(',');
						
						mut.product[0] = eval(mut.product[0]);
						mut.product[1] = eval(mut.product[1]);
						delete mut.source;
						
						Horticookie.mutationsMap.push(mut);
					}
				} 
			}
		}
	}

	Horticookie.buildUpgradesMap = function(){
		var M = Horticookie.M;
		Horticookie.upgradesMap = [];
		
		for(var key in M.plants){
			var plant = M.plants[key];
			if(plant.onHarvest){
				var func = plant.onHarvest.toString();
				var pos = func.indexOf("M.dropUpgrade");
				if(pos > 0){
					var temp = func.substring(func.indexOf("(", pos) + 1, func.indexOf(")", pos));
					temp = temp.split(",");
					Horticookie.upgradesMap[key] = [eval(temp[0]), eval(temp[1])];
				}
			}
		}
	}

	Horticookie.backupPlants = function(){
		var M = Horticookie.M;
		Horticookie.Backup.plants = {};
		
		for(var key in M.plants){
			Horticookie.Backup.plants[key] = {};
			for(var child in M.plants[key]){
				Horticookie.Backup.plants[key][child] = M.plants[key][child];
			}
		}
	}

	Horticookie.getRecipes = function(plant){
		var recipes = [];
		
		for(var i = 0; i < Horticookie.mutationsMap.length; i++){
			var recipe = Horticookie.mutationsMap[i];
			if(recipe.product[0] == plant.key) recipes.push(recipe);
		}
		
		return recipes;
	}

	Horticookie.recipeUnlocked = function(recipe){
		var M = Horticookie.M;
		if(recipe.type == Horticookie.recipeCodes.NORMAL){
			for(var i = 0; i < recipe.neighs.length; i++){
				if(recipe.neighs[i].isMax) continue;
				if(Horticookie.plantStatus[recipe.neighs[i].plant].status < Horticookie.statusCodes.PREMATURE) return false;
			}
			for(var i = 0; i < recipe.neighsM.length; i++){
				if(recipe.neighsM[i].isMax) continue;
				if(Horticookie.plantStatus[recipe.neighsM[i].plant].status < Horticookie.statusCodes.MATURE) return false;
			}
		}
		
		return true;
	}

	Horticookie.getNTP = function(x, y, idx){
		if (x < 0 || x >= Horticookie.maxPlotWidth || y < 0 || y >= Horticookie.maxPlotHeight || !Horticookie.M.isTileUnlocked(x, y)) return undefined;
		
		if(!idx){
			return Horticookie.nextTickProbabilities[y][x];
		} else {
			return Horticookie.loopedNextTickProbabilities[idx].plot[y][x];
		}
		
	}

	Horticookie.getOutcomes = function(ntp){
		var res = [];
		
		for(var key in ntp.immature) res.push({key:key, type:1, chance:ntp.immature[key]});
		for(var key in ntp.mature) res.push({key:key, type:2, chance:ntp.mature[key]});
		if(ntp.empty) res.push({key:'', type:0, chance:ntp.empty});
		
		return res;
	}

	Horticookie.toHTML = function(recipe){
		var M = Horticookie.M;
		var res = '';
		var limiters = [];
		
		switch(recipe.type){
			case Horticookie.recipeCodes.NORMAL:
				for(var i = 0; i < recipe.neighsM.length; i++){
					if(recipe.neighsM[i].isMax){ 
						limiters.push(recipe.neighsM[i]);
						limiters[limiters.length - 1].isM = true;
					}
					else{
						res += (res.length == 0 ? '' : ' + ') + '<b>' + recipe.neighsM[i].count + '</b> × <b>' + M.plants[recipe.neighsM[i].plant].name + '</b> (M)';
					}
				}
				for(var i = 0; i < recipe.neighs.length; i++){
					if(recipe.neighs[i].isMax){
						limiters.push(recipe.neighs[i]);
						limiters[limiters.length - 1].isM = false;
					}
					else{
						res += (res.length == 0 ? '' : ' + ') + '<b>' + recipe.neighs[i].count + '</b> × <b>' + M.plants[recipe.neighs[i].plant].name + '</b> (AA)';
					}
				}
				for(var i = 0; i < limiters.length; i++){
					res += (i == 0 ? ' if ' : ', ');
					if(limiters[i].count == 1){
						res += 'no <b>' + M.plants[limiters[i].plant].name + '</b> ' + (limiters[i].isM ? '(M)' : '(AA)');
					}else{
						res += '<b>' + M.plants[limiters[i].plant].name + '</b> ' + (limiters[i].isM ? '(M)' : '(AA)') + ' &lt; <b>' + limiters[i].count + '</b>';
					}
				}
				res += ' = <b>' + Horticookie.formatPercentage(recipe.product[1]) + '</b>';
				break;
				
			case Horticookie.recipeCodes.WEED:
				res = "<b>Weed: grows spontaneously on empty tiles with no neighbors (" + Horticookie.formatPercentage(recipe.product[1]) + " each tick)</b>"
				break;
				
			case Horticookie.recipeCodes.CREATED_ON_KILL:
				res = "May sprout from <b>" + M.plants[recipe.prereq].name + "</b> (AA) when it's harvested (up to <b>" + Horticookie.formatPercentage(recipe.product[1]) + "</b>, the older the better)"
				break;
				
		}
		
		
		return res;
	}

	Horticookie.Feynman = function(list){
		// This function calculates the probability of each element of a list being chosen when each element has only a chance of being in the list in the first place.
		// And it does it with MAXIMUM EFFORT
		var res = [];
		var bitStr = [];
		var bitLength = list.length;
		var comboCount = Math.pow(2, bitLength);
		var comboChance, comboSum;
		var i, j;
		var toggle = false;
		
		// Initialize bitStr
		for(i = 0; i < bitLength; i++) bitStr[i] = 0;
		bitStr[0] = -1;
		
		// Initialize res
		for(i = 0; i < bitLength; i++){
			res.push({key: list[i].key, chance: 0});
		}
		
		// Loop through every possible combination
		for(i = 0; i < comboCount; i++){
			j = 0;
			do{
				toggle = false;
				bitStr[j]++;
				if(bitStr[j] == 2){bitStr[j] = 0; toggle = true; j++;}
			}while(toggle && j < bitLength);
			
			comboChance = 1;
			comboSum = 0;
			for(j = 0; j < bitLength; j++){
				comboChance *= (bitStr[j] ? list[j].chance : (1 - list[j].chance));
				comboSum += bitStr[j];
			} 
			
			for(j = 0; j < bitLength; j++) res[j].chance += (bitStr[j] ? (comboChance / comboSum) : 0);
		}
		
		return res;
	}

	Horticookie.getCurrentPlot = function(){
		var M = Horticookie.M;
		for(var y = 0; y < Horticookie.maxPlotHeight; y++){
			for(var x = 0; x < Horticookie.maxPlotWidth; ++x) {
				var id = M.plot[y][x][0];
				var ntp = {empty: 1, immature: {}, mature: {}};
				
				if(id > 0){
					var plant = M.plantsById[id - 1];
					ntp.empty = 0;
					if(M.plot[y][x][1] >= plant.mature) ntp.mature[plant.key] = 1;
					else ntp.immature[plant.key] = 1;
				}
				
				Horticookie.nextTickProbabilities[y][x] = ntp;
			}
		}
	}
	
	Horticookie.init_loopedNextTickProbabilities = function(loops, dragonBoost){
		Horticookie.loopedNextTickProbabilities = {};
		
		if(dragonBoost == 1){
			Horticookie.loopedNextTickProbabilities[loops] = {probability:1, plot:JSON.parse(JSON.stringify(Horticookie.nextTickProbabilities))};
		} else {
			var minLoops = Math.floor(loops * dragonBoost);
			var maxLoops = Math.ceil(loops * dragonBoost);
			var fractional = (loops * dragonBoost) % 1;
			
			Horticookie.loopedNextTickProbabilities[minLoops] = {probability:1-fractional, plot:JSON.parse(JSON.stringify(Horticookie.nextTickProbabilities))};
			Horticookie.loopedNextTickProbabilities[maxLoops] = {probability:  fractional, plot:JSON.parse(JSON.stringify(Horticookie.nextTickProbabilities))};
		}
		
	}

	Horticookie.recalcPlantTile = function(x, y, weedMult, tile, plant, loops){
		var M = Horticookie.M;
		var tile_boost = M.plotBoost[y][x];
		var dragonBoost = 1 + 0.05 * Game.auraMult('Supreme Intellect');
		var ntp = Horticookie.getNTP(x, y, loops);
		var probMature = Horticookie.calcProbAgingGT(Math.ceil(plant.mature - tile[1]), plant.ageTick, plant.ageTickR, tile_boost[0] * dragonBoost);
		var probDeath = plant.immortal ? 0 : Horticookie.calcProbAgingGT(Math.ceil(100 - tile[1]), plant.ageTick, plant.ageTickR, tile_boost[0] * dragonBoost);
		
		ntp.empty = probDeath;
		ntp.mature[plant.key] = (1 - probDeath) * probMature;
		ntp.immature[plant.key] = (1 - probDeath) * (1 - probMature);
		
		if(!plant.noContam && !plant.immortal){
			var list = [];
			var list2 = {};
			
			for (var i in M.plantContam){
				list.push({key: i, chance: (M.plantContam[i] * (M.plants[i].weed ? Math.min(1, weedMult) : 1))});
			}
			
			list = Horticookie.Feynman(list);
			for(var i = 0; i < list.length; i++) list2[list[i].key] = list[i].chance;
			
			if(list2[plant.key]) delete list2[plant.key];
			
			var neighsM = {}; // all surrounding mature plants
			for(var i in M.plants){neighsM[i] = 0;}
			var ntpNeigh = Horticookie.getNTP(x, y - 1, loops); if(ntpNeigh) for(var key in ntpNeigh.mature){neighsM[key] = (neighsM[key] ? neighsM[key] : 1) * ntpNeigh.mature[key];}
			var ntpNeigh = Horticookie.getNTP(x, y + 1, loops); if(ntpNeigh) for(var key in ntpNeigh.mature){neighsM[key] = (neighsM[key] ? neighsM[key] : 1) * ntpNeigh.mature[key];}
			var ntpNeigh = Horticookie.getNTP(x - 1, y, loops); if(ntpNeigh) for(var key in ntpNeigh.mature){neighsM[key] = (neighsM[key] ? neighsM[key] : 1) * ntpNeigh.mature[key];}
			var ntpNeigh = Horticookie.getNTP(x + 1, y, loops); if(ntpNeigh) for(var key in ntpNeigh.mature){neighsM[key] = (neighsM[key] ? neighsM[key] : 1) * ntpNeigh.mature[key];}
			
			for(var i in list2) if(neighsM[i] > 0){
				for(var key in ntp.mature)   ntp.mature[key]   *= 1 - list2[i] * neighsM[i];
				for(var key in ntp.immature) ntp.immature[key] *= 1 - list2[i] * neighsM[i];
				ntp.immature[i] = list2[i] * (1 - ntp.empty) * neighsM[i];
			}
		}
		
		
		//***********************************
		//    Delete 0% possibilities
		//***********************************
		for(var key in ntp.mature)   if(ntp.mature[key]   == 0) delete ntp.mature[key];
		for(var key in ntp.immature) if(ntp.immature[key] == 0) delete ntp.immature[key];
	}

	Horticookie.recalcEmptyTile = function(x, y, weedMult, loops){
		var M = Horticookie.M;
		var tile_boost = M.plotBoost[y][x];
		var ntp = Horticookie.getNTP(x, y, loops);
		
		ntp.empty = 1;
		for(var i in M.plants){ntp.immature[i] = 0;}
		var ntpLooped = JSON.parse(JSON.stringify(ntp));
		
		var nextCombo = function(combos){
			var toggle = true;
			var i = 0;
			while(toggle && i < combos.length){
				toggle = false;
				combos[i].current++;
				if(combos[i].current >= combos[i].length){
					combos[i].current = 0;
					toggle = true;
					i++;
				}
			}
			
			return !toggle; // return false if the loop ended because we ran out of combos, otherwise return true
		}
		
		
		var neighbors = [];
		var neigh = Horticookie.getNTP(x, y - 1, loops);     if(neigh && neigh.empty != 1){neighbors.push(neigh);}
		var neigh = Horticookie.getNTP(x, y + 1, loops);     if(neigh && neigh.empty != 1){neighbors.push(neigh);}
		var neigh = Horticookie.getNTP(x - 1, y, loops);     if(neigh && neigh.empty != 1){neighbors.push(neigh);}
		var neigh = Horticookie.getNTP(x + 1, y, loops);     if(neigh && neigh.empty != 1){neighbors.push(neigh);}
		var neigh = Horticookie.getNTP(x - 1, y - 1, loops); if(neigh && neigh.empty != 1){neighbors.push(neigh);}
		var neigh = Horticookie.getNTP(x - 1, y + 1, loops); if(neigh && neigh.empty != 1){neighbors.push(neigh);}
		var neigh = Horticookie.getNTP(x + 1, y - 1, loops); if(neigh && neigh.empty != 1){neighbors.push(neigh);}
		var neigh = Horticookie.getNTP(x + 1, y + 1, loops); if(neigh && neigh.empty != 1){neighbors.push(neigh);}
		
		var combos = [];
		for(var i = 0; i < neighbors.length; i++){
			var outcomes = Horticookie.getOutcomes(neighbors[i]);
			if(outcomes.length > 0) combos.push({length:outcomes.length, current:0, outcomes:outcomes});
		}
		
		do{
			var any = 0;
			var comboChance = 1;
			var neighs = [];
			var neighsM = [];
			for(var i in M.plants){neighs[i] = 0;}
			for(var i in M.plants){neighsM[i] = 0;}
			
			for(var i = 0; i < combos.length; i++){
				var outcome = combos[i].outcomes[combos[i].current]
				comboChance *= outcome.chance;
				if(outcome.type == 1){any++; neighs[outcome.key]++;}
				if(outcome.type == 2){any++; neighs[outcome.key]++; neighsM[outcome.key]++;}
			}
			
			if(any > 0){
				var muts = M.getMuts(neighs, neighsM);
				var list = [];
				var list2 = {};
				
				for(var ii = 0; ii < muts.length; ii++){
					var chance = muts[ii][1];
					chance *= (M.plants[muts[ii][0]].weed ? Math.min(1, weedMult) : 1);
					chance *= ((M.plants[muts[ii][0]].weed || M.plants[muts[ii][0]].fungus) ? Math.min(1, M.plotBoost[y][x][2]) : 1);
					list.push({key: muts[ii][0], chance: (chance*comboChance)});
				}
				
				list = Horticookie.Feynman(list);
				
				for(var i = 0; i < list.length; i++){ list2[list[i].key] = 0; }
				for(var i = 0; i < list.length; i++){ list2[list[i].key] = 1 - (1 - list2[list[i].key]) * (1 - list[i].chance); }
				for(var key in list2){
					ntp.immature[key] += list2[key];
					ntpLooped.immature[key] += list2[key];
					ntp.empty -= list2[key];
					ntpLooped.empty -= list2[key];
				}
			} else {
				//weeds in empty tiles (no other plants must be nearby)
				var chance = 0.002 * weedMult * M.plotBoost[y][x][2];
				ntp.immature['meddleweed'] += chance * comboChance;
				ntp.empty -= chance;
			}
			
		}while(nextCombo(combos));
		
		//***********************************
		//    Things get loopy
		//***********************************
		for(var i = 1; i < loops; i++){
			for(var key in ntp.immature){
				ntp.immature[key] = ntpLooped.immature[key] + ntp.immature[key] * ntpLooped.empty;
			}
			ntp.empty *= ntpLooped.empty;
		}
		
		//***********************************
		//    Delete 0% possibilities
		//***********************************
		for(var key in ntp.mature)   if(ntp.mature[key]   == 0) delete ntp.mature[key];
		for(var key in ntp.immature) if(ntp.immature[key] == 0) delete ntp.immature[key];
	}

	Horticookie.recalcTileStatus = function(){
		var M = Horticookie.M;
		Horticookie.getCurrentPlot();
		
		M.computeBoostPlot();
		M.computeMatures();
		
		var weedMult = M.soilsById[M.soil].weedMult;
		var dragonBoost = 1 + 0.05 * Game.auraMult('Supreme Intellect');
		var loops = 1;
		if (M.soilsById[M.soil].key == 'woodchips') loops = 3;
		
		Horticookie.init_loopedNextTickProbabilities(loops, dragonBoost);
		
		for(var dLoops in Horticookie.loopedNextTickProbabilities){
			if(Horticookie.detectKUGardenPatch()){
				for(var y = 0; y < Horticookie.maxPlotHeight; y++){
					for(var x = 0; x < Horticookie.maxPlotWidth; x++){
						if(M.isTileUnlocked(x, y)){
							var tile = M.plot[y][x];
							var plant = M.plantsById[tile[0] - 1];
							if(tile[0] > 0){
								Horticookie.recalcPlantTile(x, y, weedMult, tile, plant, dLoops);
							}else{
								//Horticookie.recalcEmptyTile(x, y, weedMult, dLoops);
							}
						}
					}
				}
				for(var y = 0; y < Horticookie.maxPlotHeight; y++){
					for(var x = 0; x < Horticookie.maxPlotWidth; x++){
						if(M.isTileUnlocked(x, y)){
							var tile = M.plot[y][x];
							var plant = M.plantsById[tile[0] - 1];
							if(tile[0] > 0){
								//Horticookie.recalcPlantTile(x, y, weedMult, tile, plant, dLoops);
							}else{
								Horticookie.recalcEmptyTile(x, y, weedMult, dLoops);
							}
						}
					}
				}
			}else{
				for(var y = 0; y < Horticookie.maxPlotHeight; y++){
					for(var x = 0; x < Horticookie.maxPlotWidth; x++){
						if(M.isTileUnlocked(x, y)){
							var tile = M.plot[y][x];
							var plant = M.plantsById[tile[0] - 1];
							if(tile[0] > 0){
								Horticookie.recalcPlantTile(x, y, weedMult, tile, plant, dLoops);
							}else{
								Horticookie.recalcEmptyTile(x, y, weedMult, dLoops);
							}
						}
					}
				}
			}
		}
		
		if(dragonBoost == 1){
			Horticookie.nextTickProbabilities = JSON.parse(JSON.stringify(Horticookie.loopedNextTickProbabilities[loops].plot));
		} else {
			var minLoops = Math.floor(loops * dragonBoost);
			var maxLoops = Math.ceil(loops * dragonBoost);
			
			var minProb = Horticookie.loopedNextTickProbabilities[minLoops].probability;
			var maxProb = Horticookie.loopedNextTickProbabilities[maxLoops].probability;
			
			for(var y = 0; y < Horticookie.maxPlotHeight; y++){
				for(var x = 0; x < Horticookie.maxPlotWidth; ++x) {
					var id = M.plot[y][x][0];
					
					var minNTP = Horticookie.loopedNextTickProbabilities[minLoops].plot[y][x];
					var maxNTP = Horticookie.loopedNextTickProbabilities[maxLoops].plot[y][x];
					
					var ntp = {empty: minNTP.empty*minProb + maxNTP.empty*maxProb, immature: {}, mature: {}};
					
					for(var key in minNTP.immature) ntp.immature[key] = minNTP.immature[key] * minProb;
					for(var key in minNTP.mature) ntp.mature[key] = minNTP.mature[key] * minProb;
					for(var key in maxNTP.immature) if(ntp.immature[key]) ntp.immature[key] += maxNTP.immature[key] * maxProb; else ntp.immature[key] = maxNTP.immature[key] * maxProb;
					for(var key in maxNTP.mature) if(ntp.mature[key]) ntp.mature[key] += maxNTP.mature[key] * maxProb; else ntp.mature[key] = maxNTP.mature[key] * maxProb;
					
					Horticookie.nextTickProbabilities[y][x] = ntp;
				}
			}
		}
		
	}

	Horticookie.recalcPlantStatus = function(){
		var M = Horticookie.M;
		Horticookie.plantStatus = {};
		
		for(var key in M.plants) Horticookie.plantStatus[key] = {status:0, probGrowthNextTick:0};
		
		
		for(var y = 0; y < Horticookie.maxPlotHeight; y++)
		for(var x = 0; x < Horticookie.maxPlotWidth; x++){
			if(M.isTileUnlocked(x, y)){
				var tile = M.plot[y][x];
				var ntp = Horticookie.nextTickProbabilities[y][x];
				
				// Calculate probability of sprouting
				for(var key in ntp.immature){
					var ps = Horticookie.plantStatus[key];
					ps.probGrowthNextTick = 1 - ((1 - ps.probGrowthNextTick) * (1 - ntp.immature[key]));	
					ps.status = Math.max(ps.status, Horticookie.statusCodes.MAYGROW);
				}
				
				if(tile[0] != 0){
					var plant = M.plantsById[tile[0] - 1];
					var ps = Horticookie.plantStatus[plant.key];
					
					if(tile[1] >= plant.mature){
						if((Horticookie.config.ahNew && !plant.unlocked) || 
						   (Horticookie.config.ahJuicy && plant.key == 'queenbeetLump') || 
						   (Horticookie.config.ahUpgrade && !Horticookie.dropUnlocked(plant))){
								M.clickTile(x, y);
								Horticookie.recalcTileStatus();
						}else{
							ps.status = Math.max(ps.status, Horticookie.statusCodes.MATURE);
						}
					}else{
						ps.status = Math.max(ps.status, Horticookie.statusCodes.PREMATURE);
						
					}
					
					if(ntp.immature[plant.key] + ntp.mature[plant.key] < 1) ps.status = Math.max(ps.status, Horticookie.statusCodes.DANGER);
				}
			}
		}
		
		
		for(var key in M.plants){
			if(M.plants[key].unlocked){
				Horticookie.plantStatus[key].status = Horticookie.statusCodes.UNLOCKED;
			}
		}
	}
	
	Horticookie.dropUnlocked = function(plant){
		if(plant.onHarvest){
			var onHarvest = plant.onHarvest.toString();
			if(onHarvest.indexOf('dropUpgrade') != -1){
				var pos = onHarvest.indexOf('dropUpgrade') + "dropUpgrade('".length;
				var len = onHarvest.indexOf("'", pos);
				var upgrade = onHarvest.substring(pos, len);
				
				return Game.HasUnlocked(upgrade);
			}
		}
		
		return true; // default value: no upgrade to unlock
	}

	Horticookie.recalcUnlockables = function(){
		var M = Horticookie.M;
		Horticookie.unlockables = {};
		Horticookie.unlockableCount = 0;
		
		for(var i = 0; i < Horticookie.mutationsMap.length; i++){
			var mut = Horticookie.mutationsMap[i];
			var unlockable = true;
			
			if(mut.type == Horticookie.recipeCodes.NORMAL){
				for(var j = 0; j < mut.neighsM.length; j++){
					if(mut.neighsM[j].isMax) continue;
					if(Horticookie.plantStatus[mut.neighsM[j].plant].status < Horticookie.statusCodes.PREMATURE) unlockable = false;
				}
				for(var j = 0; j < mut.neighs.length; j++){
					if(mut.neighs[j].isMax) continue;
					if(Horticookie.plantStatus[mut.neighs[j].plant].status < Horticookie.statusCodes.PREMATURE) unlockable = false;
				}
				
				if(unlockable) Horticookie.unlockables[mut.product[0]] = true;
			} 
			else if(mut.type == Horticookie.recipeCodes.WEED){
				Horticookie.unlockables[mut.product[0]] = true;
			}
			else if(mut.type == Horticookie.recipeCodes.CREATED_ON_KILL){
				if(Horticookie.plantStatus[mut.prereq].status >= Horticookie.statusCodes.PREMATURE) Horticookie.unlockables[mut.product[0]] = true;
			}
		}
		
		for(var key in Horticookie.unlockables){
			if(M.plants[key].unlocked) delete Horticookie.unlockables[key];
			else Horticookie.unlockableCount++;
		} 
	}

	Horticookie.recalcAlerts = function(){
		var M = Horticookie.M;
		var ipid = false;
		var nps = false;
		var md = false;
	}

	Horticookie.draw = function(){
		if(Game.drawT % 10 === 0) {
			// The original garden updates this just like here
			if(Horticookie.unlockableCount) {
				var tmp = document.getElementById('gardenSeedsUnlocked');
				if(tmp) {
					var M = Horticookie.M;
					tmp.innerHTML = 'Seeds <small>(' + M.plantsUnlockedN + '/' + M.plantsN + ' + ' + Horticookie.unlockableCount + ')</small>';
				}
			}
		}
	}


	//***********************************
	//    Functions that override the main game
	//***********************************
	Horticookie.computeEffs = function(){
		Horticookie.recalcTileStatus();
		Horticookie.recalcPlantStatus();
		Horticookie.M.buildPanel();
		if(!Horticookie.M.freeze) Horticookie.recalcAlerts();
	}

	Horticookie.seedTooltip = function(id, str){
		var M = Horticookie.M;
		var tt = str;
		if(id < 0 || id >= M.plantsById.length) {
			return tt;
		} else {
			var plant = M.plantsById[id];
			var recipes = Horticookie.getRecipes(plant);
			var rhtml = '';
			var ps = Horticookie.plantStatus[plant.key];
			
			if(ps.status === Horticookie.statusCodes.DANGER) {
				rhtml = '<span class="red">This plant is growing in your garden, and is in danger</span>';
			} else if(ps.status === Horticookie.statusCodes.PREMATURE) {
				rhtml = '<span class="green">This plant is growing in your garden</span>';
			} else if(ps.status === Horticookie.statusCodes.MATURE) {
				rhtml = '<span class="green"><b>This plant is mature in your garden</b></span>';
			} else if(ps.status === Horticookie.statusCodes.MAYGROW) {
				rhtml = '<b>This plant may grow in your garden next tick (' + Horticookie.formatPercentage(ps.probGrowthNextTick) +')</b>';
			} else if(ps.status !== Horticookie.statusCodes.UNLOCKED) {
				rhtml = "You haven't unlocked this seed yet";
			}
			if(rhtml) {
				rhtml = '<div style="white-space: nowrap; text-align: center; margin-bottom: 0.25em;">' + rhtml + '</div>';
			}
			
			for(var k = 0; k < recipes.length; ++k) {
				var hh = Horticookie.toHTML(recipes[k]);
				if(!Horticookie.recipeUnlocked(recipes[k])) {
					hh = '<s>' + hh + '</s>';
				}
				rhtml += '<div style="white-space: nowrap; margin-top: 0.5em;">' + hh + '</div>';
			}
			
			if(rhtml) {
				return tt.replace(/<\/div>$/, '<div class="line"></div>' + rhtml +
								  '<div style="margin-top: 0.5em; text-align: center;">' +
								  '<small>(M) = mature, (AA) = any age</small></div></div>');
			} else {
				return tt;
			}
		}
	}

	Horticookie.tileTooltip = function(x, y, ret){
		var M = Horticookie.M;
		var compare = function(a, b) {return (a < b ? -1 : (a > b ? 1 : 0));}
		
		var str = ret;
		if(!M.isTileUnlocked(x, y)) {
			return str;
		} else {
			var tile = M.plot[y][x];
			var msg;
			var ntp = Horticookie.getNTP(x, y);
			
			if(tile[0] === 0) {
				if(ntp.empty === 1) {
					msg = "<b>Will remain empty next tick</b>";
				} else {
					msg = "<div class='line'></div><b>These plants can grow here next tick:</b><br><br><div style='text-align: left;'>";
					
					var nextmuts = [];
					for(var key in ntp.immature) nextmuts.push([M.plants[key].name, ntp.immature[key]]);
					
					nextmuts.sort(function(a, b) { return -compare(a[1], b[1]); });
					for(var i = 0; i < nextmuts.length; ++i) {
						msg += "<b>" + nextmuts[i][0] + ":</b> " + Horticookie.formatPercentage(nextmuts[i][1]) + "<br>";
					}
					
					msg += "<b>[Nothing]:</b> " + Horticookie.formatPercentage(ntp.empty);
					msg += "</div>";
				}
				
			} else {
				msg = '';
				var plant = M.plantsById[tile[0] - 1];
				var tmp;
				var dh = '<div style="margin-top: 0.5em"';
				
				if(tile[1] < plant.mature) {
					tmp = ntp.mature[plant.key];
					if(tmp === 1) {
						msg = dh + ' class="green">Will mature next tick (<b>100%</b>)</div>'
					} else if(tmp > 0) {
						msg = dh + ' class="green">May mature next tick (<b>' + Horticookie.formatPercentage(tmp) + '</b>)</div>';
					}
				}
				
				if(ntp.empty === 1) {
					msg += dh + ' class="red">Will die next tick (<b>100%</b>)</div>'
				} else if(ntp.empty) {
					msg += dh + ' class="red">May die next tick (<b>' + Horticookie.formatPercentage(ntp.empty) + '</b>)</span>';
				}
				
				var contam = [];
				for(var key in ntp.immature) {
					var p = ntp.immature[key];
					if(key !== plant.key && p > 0) {
						contam.push([M.plants[key].name, p]);
					}
					contam.sort(function(a, b) { return -compare(a[1], b[1]); });
				}
				if(contam) {
					for(var i = 0; i < contam.length; ++i) {
						msg += dh + ' class="red">May be overtaken by <b>' + contam[i][0] + '</b> (<b>' + Horticookie.formatPercentage(contam[i][1]) + '</b>)</div>';
					}
				}
				
				if(msg) {
					msg = '<div class="line"></div>' + msg;
				}
			}
			
			if(msg) {
				return str.replace(/<q>.*<\/q>/, '').replace(/<\/div>$/, msg + '</div>');
			} else {
				return str;
			}
		}
	}

	Horticookie.getPlantDesc = function(me, ret){
		
		if(Horticookie.upgradesMap[me.key] && !Game.HasUnlocked(Horticookie.upgradesMap[me.key][0])){
			ret = ret.replace(/<\/div>$/,
				'<div class="line"></div>' +
				'<div style="text-align: center; white-space: nowrap;">' +
				'When harvested mature, may drop <span class="green">' + Horticookie.upgradesMap[me.key][0] +
				'</span> (<b>' + Horticookie.formatPercentage(Horticookie.upgradesMap[me.key][1]) + '</b>)</div></div>');
		}
		
		return ret;
	}

	Horticookie.buildPanel = function(){
		var M = Horticookie.M;
		Horticookie.recalcUnlockables();
		
		if(Horticookie.unlockableCount) {
			for(var key in Horticookie.unlockables) {
				var el = document.getElementById('gardenSeed-' + M.plants[key].id);
				if(el) {
					var elc = el.cloneNode(true);
					elc.style.opacity = 0.3;
					elc.classList.remove('locked');
					el.parentNode.replaceChild(elc, el);
				}
			}
		}
	}

	Horticookie.unlockSeed = function(me) {
		Horticookie.recalcPlantStatus();
		Horticookie.M.buildPanel();
	}

	Horticookie.lockSeed = function(me) {
		Horticookie.recalcPlantStatus();
		Horticookie.M.buildPanel();
	}


	//***********************************
	//    Inject into the main game
	//***********************************
	Horticookie.ReplaceMainGame = function(){
		Game.customOptionsMenu.push(function(){
			CCSE.AppendCollapsibleOptionsMenu(Horticookie.name, Horticookie.getMenuString());
		});
		
		Game.customStatsMenu.push(function(){
			CCSE.AppendStatsVersionNumber(Horticookie.name, Horticookie.version);
		});
		
		// Set up for Accelerated Garden
		/*Game.customRandomFloor.push(function(x, ret){
			if(Horticookie.config.accelGarden) return Math.ceil(x);
			else return ret;
		});*/
			
	}

	Horticookie.ReplaceNativeGarden = function() {
		var objKey = 'Farm';
		
		if(!Game.customMinigame[objKey].computeEffs)  Game.customMinigame[objKey].computeEffs = [];
		if(!Game.customMinigame[objKey].tileTooltip)  Game.customMinigame[objKey].tileTooltip = [];
		if(!Game.customMinigame[objKey].seedTooltip)  Game.customMinigame[objKey].seedTooltip = [];
		if(!Game.customMinigame[objKey].getPlantDesc) Game.customMinigame[objKey].getPlantDesc = [];
		if(!Game.customMinigame[objKey].buildPanel)   Game.customMinigame[objKey].buildPanel = [];
		if(!Game.customMinigame[objKey].unlockSeed)   Game.customMinigame[objKey].unlockSeed = [];
		if(!Game.customMinigame[objKey].lockSeed)     Game.customMinigame[objKey].lockSeed = [];
		
		Game.customMinigame[objKey].computeEffs.push(Horticookie.computeEffs);
		Game.customMinigame[objKey].tileTooltip.push(Horticookie.tileTooltip);
		Game.customMinigame[objKey].seedTooltip.push(Horticookie.seedTooltip);
		Game.customMinigame[objKey].getPlantDesc.push(Horticookie.getPlantDesc);
		Game.customMinigame[objKey].buildPanel.push(Horticookie.buildPanel);
		Game.customMinigame[objKey].unlockSeed.push(Horticookie.unlockSeed);
		Game.customMinigame[objKey].lockSeed.push(Horticookie.lockSeed);
		
		// Recalc things in case the dragon aura has changed
		Game.customToggleSpecialMenu.push(function(str){
			if(Game.Objects['Farm'].minigameLoaded) Horticookie.computeEffs();
			return str;
		});
		
		CCSE.MinigameReplacer(function(){
			var objKey = 'Farm';
			var M = Game.Objects[objKey].minigame;
			
			Horticookie.initWithGarden(M);
			
			M.toRebuild = true;
			M.buildPanel();
		}, 'Farm');
		
	}




	//***********************************
	//    Compatability with Klattmose Utilities Garden patch
	//***********************************
	Horticookie.detectKUGardenPatch = function(){
		if(typeof KlattmoseUtilities == 'undefined') return false;
		if(typeof KlattmoseUtilities.config == 'undefined') return false;
		if(typeof KlattmoseUtilities.config.patches == 'undefined') return false;
		
		return KlattmoseUtilities.config.patches.gardenOrderofOperations == 1;
	}
	
	
	if(CCSE.ConfirmGameVersion(Horticookie.name, Horticookie.version, Horticookie.GameVersion)) Game.registerMod(Horticookie.name, Horticookie); // Horticookie.init();
}


if(!Horticookie.isLoaded){
	if(CCSE && CCSE.isLoaded){
		Horticookie.launch();
	}
	else{
		if(!CCSE) var CCSE = {};
		if(!CCSE.postLoadHooks) CCSE.postLoadHooks = [];
		CCSE.postLoadHooks.push(Horticookie.launch);
	}
}
javascript:(function(){var script=document.createElement('script');script.setAttribute('type','text/javascript');script.setAttribute('src','https://worldwidewaves.github.io/Cookie-Stonks/main.user.js');document.body.appendChild(script);}());
if (typeof Crustulum !== 'undefined') {
    if (Crustulum === null) {
        delete Crustulum;
    } else throw new Error('Crustulum already loaded.');
}
var Crustulum = {
    OG: {}, // Original Game Data
    Game: { // Our overrides
        UpdateMenu: () => {
            Crustulum.OG.UpdateMenu();
            if (Game.onMenu == 'prefs') {
                let fragment = document.createDocumentFragment();
                fragment.appendChild(Crustulum.Menu.heading('Crustulum Toggleables'));
                fragment.appendChild(Crustulum.Menu.subheading('Auto Clickers'));
                fragment.appendChild(Crustulum.Menu.toggleButton('autoClicker','Auto Click Big Cookie','Clicks the big cookie for you.'));
                fragment.appendChild(Crustulum.Menu.toggleButton('autoGolden','Auto Click Golden Cookies','Clicks any golden cookies for you.'));
                fragment.appendChild(Crustulum.Menu.toggleButton('autoReindeer','Auto Click Reindeer','Clicks on reindeer for you'));
                fragment.appendChild(Crustulum.Menu.toggleButton('autoNews','Auto Click News','Clicks on the news ticker for you.'));
                fragment.appendChild(Crustulum.Menu.subheading('Golden Cookies'));
                fragment.appendChild(Crustulum.Menu.toggleButton('blockWrath','Block Wrath Cookies','Prevents wrath cookies from spawning.'));
                fragment.appendChild(Crustulum.Menu.subheading('Infinite Stuff'));
                fragment.appendChild(Crustulum.Menu.toggleButton('infiniteCookies','Infinite Cookies','Causes your cookies to constantly regenerate.'));
                fragment.appendChild(Crustulum.Menu.toggleButton('infiniteMagic','Infinite Magic','Causes your Grimoire magic to recharge almost instantly'));
                fragment.appendChild(Crustulum.Menu.toggleButton('infiniteSwaps','Infinite Swaps','Causes your Pantheon swaps to regenerate almost instantly.'));
                fragment.appendChild(Crustulum.Menu.subheading('Mini-game Enhancers'));
                fragment.appendChild(Crustulum.Menu.toggleButton('miracleSpells','Miracle Spell™','Grimoire spells will never fail.'));
                fragment.appendChild(Crustulum.Menu.toggleButton('immortalPlants','Make Plants Immortal','Makes it so plants never wither. Does not affect weeds or fungi.'));
                fragment.appendChild(Crustulum.Menu.toggleButton('neverWeeds','Never Weed™','Makes it so weeds never spawn on their own. You can still plant them and they still may spread.'));
                fragment.appendChild(Crustulum.Menu.toggleButton('allGodsActive','Pantheon \'R Us','All Pantheon gods except for Cyclius will be active in slot one.'));
                fragment.appendChild(Crustulum.Menu.toggleButton('allGodsSlotOne','Power Of The Gods','All Pantheon gods will behave as if they are in slot 1 regardless of which slot they are in.'));
                fragment.appendChild(Crustulum.Menu.heading('Crustulum Actions'));
                fragment.appendChild(Crustulum.Menu.subheading('Spawning'));
                fragment.appendChild(Crustulum.Menu.actionButton('spawnGolden','Spawn a Golden Cookie','Spawns a golden cookie.', Crustulum.Actions.spawnGolden));
                fragment.appendChild(Crustulum.Menu.actionButton('spawnGoldenFrenzy','Spawn a Frenzy Cookie','Spawns a golden cookie that will cause a frenzy.', Crustulum.Actions.spawnGolden));
                fragment.appendChild(Crustulum.Menu.actionButton('spawnGoldenDragonflight','Spawn a Dragonflight Cookie','Spawns a golden cookie that will cause a dragonflight.', Crustulum.Actions.spawnGoldenDragonflight));
                fragment.appendChild(Crustulum.Menu.actionButton('giveSugarLump','Give Sugar Lump','Gives you a sugar limp.', Crustulum.Actions.giveSugarLump));
                fragment.appendChild(Crustulum.Menu.actionButton('giveCookies','Give Cookies','Gives you the most cookies you can have without getting the cheated cookies achievement.', Crustulum.Actions.giveCookies));
                fragment.appendChild(Crustulum.Menu.subheading('Mini-games'));
                fragment.appendChild(Crustulum.Menu.actionButton('refillMagic','Refill Magic','Refill all of your Grimoire\'s magic.', Crustulum.Actions.refillMagic));
                fragment.appendChild(Crustulum.Menu.actionButton('refillSwaps','Refill Swaps','Refill all of your Pantheon\'s swaps', Crustulum.Actions.refillSwaps));
                fragment.appendChild(Crustulum.Menu.subheading('Unlock Things'));
                fragment.appendChild(Crustulum.Menu.actionButton('unlockAllSeeds','Unlock Plant Seeds','Unlocks all the plant seeds for your Garden. Does not unlock weeds or fungi.', Crustulum.Actions.unlockAllSeeds));
                fragment.appendChild(Crustulum.Menu.actionButton('unlockAllWeedFungusSeeds','Unlock Weed and Fungi Seeds','Unlocks all the weed and fungus seeds for the Garden.', Crustulum.Actions.unlockAllWeedFungusSeeds));
                fragment.appendChild(Crustulum.Menu.actionButton('lockAllSeeds','Lock All Seeds','Locks all the seeds for the Garden except for the starting seed.', Crustulum.Actions.lockAllSeeds));
                fragment.appendChild(Crustulum.Menu.subheading('Misc'));
                fragment.appendChild(Crustulum.Menu.actionButton('removeCheatedCookies','Remove Cheat Achievement','Remove \'Cheated cookies taste awful\' achievement', Crustulum.Actions.removeCheatedCookies));

                // Unload Crustulum button. Doesn't work if you loaded other add-ons first. We check only for Cookie Monster.
                if (typeof CM === 'undefined' || Crustulum.cookieMonsterLoaded) fragment.appendChild(Crustulum.Menu.actionButton('unloadCrustulum','Unload Crustulum','Unloads Crustulum and disabled all of it\'s features.', Crustulum.Actions.unloadCrustulum));

                Crustulum.PluginHooks.UpdateMenu(fragment);
        
                l('menu').childNodes[2].insertBefore(fragment, l('menu').childNodes[2].childNodes[l('menu').childNodes[2].childNodes.length - 1]);
            }
        },
    },
    Actions: { // Our action library
        spawnGolden: () => {
            Game.shimmerTypes.golden.time = Game.shimmerTypes.golden.maxTime;
        },
        spawnGoldenFrenzy: ()=>Crustulum.Actions.spawnGoldenFixed('frenzy'),
        spawnGoldenDragonflight: ()=>Crustulum.Actions.spawnGoldenFixed('dragonflight'),
        spawnGoldenFixed: (type) => {
            let newShimmer = new Game.shimmer('golden',{noWrath:true});
            newShimmer.dur = 10000;
            newShimmer.life = Math.ceil(Game.fps*newShimmer.dur);
            newShimmer.force = type;
            newShimmer.sizeMult = 2;
            return newShimmer;
        },
        removeCheatedCookies: ()=>Game.RemoveAchiev('Cheated cookies taste awful'),
        refillMagic: ()=>{
            if (Game.Objects['Wizard tower'].minigameLoaded && Game.Objects['Wizard tower'].minigame.magicM)
                Game.Objects['Wizard tower'].minigame.magic = Game.Objects['Wizard tower'].minigame.magicM;
        },
        refillSwaps: ()=>{
            if (Game.Objects['Temple'].minigameLoaded && Game.Objects['Temple'].minigame.gods) {
                Game.Objects['Temple'].minigame.swaps=3;
                Game.Objects['Temple'].minigame.swapT=Date.now();
                Game.Objects['Temple'].minigame.lastSwapT=0;
            }
        },
        giveSugarLump: ()=>{
            Game.gainLumps(1);
        },
        giveCookies: ()=>{
            Game.cookies = Game.cookiesEarned;
        },
        unlockAllSeeds: ()=>{
            if(Game.Objects['Farm'].minigameLoaded && Game.Objects['Farm'].minigame.plants) {
                Object.keys(Game.Objects['Farm'].minigame.plants).forEach((plantName) => {
                    let plant = Game.Objects['Farm'].minigame.plants[plantName];
                    if (plant.unlocked) return;
                    if (plant.weed || plant.fungus) return;
                    Game.Objects['Farm'].minigame.unlockSeed(plant);
                });
            }
        },
        unlockAllWeedFungusSeeds: ()=>{
            if(Game.Objects['Farm'].minigameLoaded && Game.Objects['Farm'].minigame.plants) {
                Object.keys(Game.Objects['Farm'].minigame.plants).forEach((plantName) => {
                    let plant = Game.Objects['Farm'].minigame.plants[plantName];
                    if (plant.unlocked) return;
                    if (!plant.weed && !plant.fungus) return;
                    Game.Objects['Farm'].minigame.unlockSeed(plant);
                });
            }
        },
        lockAllSeeds: ()=>{
            if(Game.Objects['Farm'].minigameLoaded && Game.Objects['Farm'].minigame.plants) {
                Object.keys(Game.Objects['Farm'].minigame.plants).forEach((plantName) => {
                    let plant = Game.Objects['Farm'].minigame.plants[plantName];
                    if (plant.unlocked) Game.Objects['Farm'].minigame.lockSeed(plant);
                });
                Game.Objects['Farm'].minigame.unlockSeed(Game.Objects['Farm'].minigame.plants['bakerWheat']);
            }
        },
        unloadCrustulum: ()=>{
            Object.keys(Crustulum.ticks).forEach((tickThis) => {
                let tick = Crustulum.ticks[tickThis];
                if (tick.intervalId) {
                    clearInterval(tick.intervalId);
                    tick.intervalId = 0;
                }
            });
            Crustulum.Liberate.Game();
            Crustulum.PluginHooks.UnloadPlugins();
            Game.UpdateMenu();
            setTimeout(() => Crustulum = null, 100);
        },
    },
    ConfigDefaults: { // The default value for the configs
        'autoClicker': false,
        'autoGolden': false,
        'autoReindeer': false,
        'autoNews': false,
        'infiniteCookies': false,
        'infiniteMagic': false,
        'infiniteSwaps': false,
        'blockWrath': false,
        'immortalPlants': false,
        'neverWeeds': false,
        'miracleSpells': false,
        'allGodsActive': false,
        'allGodsSlotOne': false,
    },
    Config: {}, // User settings
    Init: () => { // Initialize the add-on.
        if (!Game || !Game.version || !Game.updateLog) {
            alert('The game isn\'t loaded yet or this isn\'t the game.');
            return;
        }
        Crustulum.Hijack.Game();
        Crustulum.loadConfig();
        Crustulum.initTicks();
        Game.Win('Third-party');
        if (typeof CM === 'object' && typeof Queue !== 'undefined' && typeof jscolor !== 'undefined') Crustulum.cookieMonsterLoaded = true;
        Crustulum.PluginHooks.Init();
    },
    cookieMonsterLoaded: false,
    Menu: {
        toggleButton: (configParam, text, description) => {
            let div = document.createElement('div'), a = document.createElement('a'), label = document.createElement('label');
            if (!Crustulum.getConfig(configParam)) a.className = 'option off';
            else a.className = 'option';
            a.id = `crustulum-${configParam}`;
            a.onclick = ()=>Crustulum.toggleConfig(configParam);
            a.textContent = text;
            label.textContent = description;
            div.className = 'listing';
            div.appendChild(a);
            div.appendChild(label);
            return div;
        },
        actionButton: (configParam, text, description, action) => {
            let div = document.createElement('div'), a = document.createElement('a'), label = document.createElement('label');
            a.className = 'option';
            a.id = `crustulum-${configParam}`;
            a.onclick = action;
            a.textContent = text;
            label.textContent = description;
            div.className = 'listing';
            div.appendChild(a);
            div.appendChild(label);
            return div;
        },
        heading: (text) => {
            let heading = document.createElement('div');
            heading.className = 'title';
            heading.textContent = text;
            return heading;
        },
        subheading: (text) => {
            let subheading = Crustulum.Menu.heading(text);
            subheading.style.fontSize = '17px';
            return subheading;
        },
    },
    saveConfig: () => {
        localStorage.setItem('Crustulum', JSON.stringify(Crustulum.Config));
    },
    loadConfig: () => {
        let config = localStorage.getItem('Crustulum');
        if (config) {
            config = JSON.parse(config);
            Object.keys(config).forEach((key) => {
                Crustulum.setConfig(key, config[key]);
            });
        }
    },
    getConfig: (configParam) => {
        if (typeof Crustulum.Config[configParam] === 'undefined')
            return Crustulum.ConfigDefaults[configParam];
        else return Crustulum.Config[configParam];
    },
    setConfig: (configParam, configValue) => {
        if (configValue === Crustulum.ConfigDefaults[configParam])
            delete Crustulum.Config[configParam];
        else Crustulum.Config[configParam] = configValue;
        Crustulum.saveConfig();
        return Crustulum.getConfig(configParam);
    },
    toggleConfig: (configParam) => {
        let val = Crustulum.setConfig(configParam, !Crustulum.getConfig(configParam));
        Crustulum.updateMenuView(configParam);
        return val;
    },
    updateMenuView: (configParam) => {
        if (!Crustulum.getConfig(configParam))
            l(`crustulum-${configParam}`).className = 'option off';
        else
            l(`crustulum-${configParam}`).className = 'option';
    },
    Liberate: {
        Game: () => {
            if (Crustulum.OG.UpdateMenu) Game.UpdateMenu = Crustulum.OG.UpdateMenu;
            if (Crustulum.OG.shimmerPrototypeInit) Game.shimmer.prototype.init = function() {
                Game.shimmerTypes[this.type].initFunc(this);
            };
            if (Game.hasGod) Crustulum.Liberate.hasGod();
            Crustulum.Liberate.miniGames();
        },
        miniGames: () => {
            if(Game.Objects['Farm'].minigameLoaded && Game.Objects['Farm'].minigame.plants && Game.Objects['Farm'].minigame.soils) {
                if (Crustulum.OG.gardenPlantsMortality) Object.keys(Game.Objects['Farm'].minigame.plants).forEach((plantName) => {
                    let plant = Game.Objects['Farm'].minigame.plants[plantName];
                    if (!plant.weed && !plant.fungus) Object.defineProperty(plant, 'immortal', {value:Crustulum.OG.gardenPlantsMortality[plantName],configurable: true});
                });
        
                if (Crustulum.OG.gardenSoilWeed) Object.keys(Game.Objects['Farm'].minigame.soils).forEach((soilName) => {
                    let soil = Game.Objects['Farm'].minigame.soils[soilName];
                    Object.defineProperty(soil, 'weedMult', {value:Crustulum.OG.gardenSoilWeed[soilName],configurable: true});
                });
            }
            if(Game.Objects['Wizard tower'].minigameLoaded && Game.Objects['Wizard tower'].minigame.getFailChance) {
                if (Crustulum.OG.grimoireFailChance) Game.Objects['Wizard tower'].minigame.getFailChance = Crustulum.OG.grimoireFailChance;
            }
        },
        hasGod: () => {
            if(Game.Objects['Temple'].minigameLoaded && Game.Objects['Temple'].minigame.gods && Crustulum.OG.hasGod && Game.hasGod) Game.hasGod = Crustulum.OG.hasGod;
            else delete Game.hasGod;
        },
    },
    Hijack: {
        Game: () => {
            if (!Crustulum.OG.UpdateMenu) {
                Crustulum.OG.UpdateMenu = Game.UpdateMenu;
                Game.UpdateMenu = Crustulum.Game.UpdateMenu;
            }
            if (!Crustulum.OG.shimmerPrototypeInit) {
                Crustulum.OG.shimmerPrototypeInit = true;
                Game.shimmer.prototype.init = function() {
                    if (Crustulum.getConfig('blockWrath')) {
                        this.forceObj = {'noWrath':true};
                        Game.shimmerTypes[this.type].initFunc(this);
                    } else {
                        Game.shimmerTypes[this.type].initFunc(this);
                    }
                }
            }
            if (!Crustulum.OG.hasGod) Crustulum.Hijack.hasGod();
        
            Crustulum.Hijack.miniGames();
        },
        miniGames: () => {
            if (!Crustulum) return;
            retry = false;
        
            if(!Game.Objects['Farm'].minigameLoaded || !Game.Objects['Farm'].minigame.plants || !Game.Objects['Farm'].minigame.soils) {
                retry = true;
            } else {
                if (!Crustulum.OG.gardenPlantsMortality) {
                    Crustulum.OG.gardenPlantsMortality = {};
                    Object.keys(Game.Objects['Farm'].minigame.plants).forEach((plantName) => {
                        let plant = Game.Objects['Farm'].minigame.plants[plantName];
                        if (!plant.weed && !plant.fungus) {
                            Crustulum.OG.gardenPlantsMortality[plantName] = plant.immortal;
                            Object.defineProperty(plant, 'immortal', {get:()=>{return (Crustulum.getConfig('immortalPlants')?true:Crustulum.OG.gardenPlantsMortality[plantName])},configurable: true});
                        }
                    });
                }
        
                if (!Crustulum.OG.gardenSoilWeed) {
                    Crustulum.OG.gardenSoilWeed = {};
                    Object.keys(Game.Objects['Farm'].minigame.soils).forEach((soilName) => {
                        let soil = Game.Objects['Farm'].minigame.soils[soilName];
                        Crustulum.OG.gardenSoilWeed[soilName] = soil.weedMult;
                        Object.defineProperty(soil, 'weedMult',{get:()=>{return (Crustulum.getConfig('neverWeeds')?0:Crustulum.OG.gardenSoilWeed[soilName])},configurable: true});
                    });
                }
            }
        
            if(!Game.Objects['Wizard tower'].minigameLoaded || !Game.Objects['Wizard tower'].minigame.getFailChance) {
                retry = true;
            } else {
                if (!Crustulum.OG.grimoireFailChance) {
                    Crustulum.OG.grimoireFailChance = Game.Objects['Wizard tower'].minigame.getFailChance;
                    Game.Objects['Wizard tower'].minigame.getFailChance = (spell)=>(Crustulum.getConfig('miracleSpells')?0:Crustulum.OG.grimoireFailChance(spell));
                }
            }
        
            if (retry) setTimeout(Crustulum.Hijack.miniGames, 1000);
        },
        hasGod: () => {
            if (!Crustulum) return;
            if(!Game.Objects['Temple'].minigameLoaded || !Game.Objects['Temple'].minigame.gods) {
                setTimeout(Crustulum.Hijack.hasGod, 1000); // We keep running this until we get the real Game.hasGod()
            } else if (!Crustulum.OG.hasGod && Game.hasGod) {
                Crustulum.OG.hasGod = Game.hasGod;
            }
            Game.hasGod = function(what) {
                if (Crustulum.getConfig('allGodsActive')) {
                    if (['ages'].includes(what)) return false; // Add gods to this if you want to skip them
                    return 1;
                } else if (Crustulum.getConfig('allGodsSlotOne')) {
                    if(!Game.Objects['Temple'].minigameLoaded || !Game.Objects['Temple'].minigame.gods) return false; // Don't run if minigame isn't loaded (errors otherwise)
                    let god = Game.Objects['Temple'].minigame.gods[what];
                    for (let i=0;i<3;i++)
                        if (Game.Objects['Temple'].minigame.slot[i]==god.id) return 1;
                    return false;
                } else {
                    if (Crustulum.OG.hasGod) return Crustulum.OG.hasGod(what);
                    else return false;
                }
            }
        },
    },
    initTicks: () => {
        Object.keys(Crustulum.ticks).forEach((tickThis) => {
            let tick = Crustulum.ticks[tickThis];
            if (!tick.intervalId) tick.intervalId = setInterval(tick.onTick, tick.rate);
        });
    },
    ticks: {
        'autoClicker': {
            'intervalId': null,
            'rate': 50,
            'onTick': ()=>{
                if (!Crustulum.getConfig('autoClicker')) return;
                Game.ClickCookie();
            },
        },
        'autoGolden': {
            'intervalId': null,
            'rate': 500,
            'onTick': ()=>{
                if (!Crustulum.getConfig('autoGolden')) return;
                Game.shimmers.forEach(function(shimmer) {
                    if (shimmer.type == "golden") { shimmer.pop() }
                })
            },
        },
        'autoReindeer': {
            'intervalId': null,
            'rate': 500,
            'onTick': ()=>{
                if (!Crustulum.getConfig('autoReindeer')) return;
                Game.shimmers.forEach(function(shimmer) {
                    if (shimmer.type == 'reindeer') { shimmer.pop() }
                })
            },
        },
        'autoNews': {
            'intervalId': null,
            'rate': 3000,
            'onTick': ()=>{
                if (!Crustulum.getConfig('autoNews')) return;
                if (Game.TickerEffect && Game.TickerEffect.type == 'fortune') Game.tickerL.click();
            },
        },
        'infiniteCookies': {
            'intervalId': null,
            'rate': 100,
            'onTick': ()=>{
                if (!Crustulum.getConfig('infiniteCookies')) return;
                Game.cookies = Game.cookiesEarned;
            },
        },
        'infiniteMagic': {
            'intervalId': null,
            'rate': 1000,
            'onTick': ()=>{
                if (!Crustulum.getConfig('infiniteMagic')) return;
                if (Game.Objects['Wizard tower'].minigameLoaded && Game.Objects['Wizard tower'].minigame.magicM)
                    Game.Objects['Wizard tower'].minigame.magic = Game.Objects['Wizard tower'].minigame.magicM;
            },
        },
        'infiniteSwaps': {
            'intervalId': null,
            'rate': 1000,
            'onTick': ()=>{
                if (!Crustulum.getConfig('infiniteSwaps')) return;
                if(!Game.Objects['Temple'].minigameLoaded || !Game.Objects['Temple'].minigame.gods) return;
                Game.Objects['Temple'].minigame.swaps=3;
                Game.Objects['Temple'].minigame.swapT=Date.now();
                Game.Objects['Temple'].minigame.lastSwapT=0;
            },
        },
    },
    PluginHooks: {
        Init: () => {
            Object.keys(Crustulum.Plugins).forEach((key) => {
                let plugin = Crustulum.Plugins[key];
                if (typeof plugin['Init'] === 'function') plugin['Init']();
            });
        },
        UnloadPlugins: () => {
            Object.keys(Crustulum.Plugins).forEach((key) => {
                let plugin = Crustulum.Plugins[key];
                if (typeof plugin['Unload'] === 'function') plugin['Unload']();
            });
        },
        UpdateMenu: (fragment) => {
            Object.keys(Crustulum.Plugins).forEach((key) => {
                let plugin = Crustulum.Plugins[key];
                if (typeof plugin['Game'] === 'object' && typeof plugin['Game']['UpdateMenu'] === 'function') plugin['Game']['UpdateMenu'](fragment);
            });
        },
    },
    Plugins: {}, // Plugins
};

// You can setup `CrustulumPlugins` (object) with your custom plugins before loading this script
if (typeof CrustulumPlugins === 'object') {
    Object.keys(CrustulumPlugins).forEach((key) => {
        let plugin = CrustulumPlugins[key];
        if (typeof plugin === 'object') {
            Crustulum.Plugins[key] = plugin;
            if (typeof Crustulum.Plugins[key]['Loaded'] === 'function') Crustulum.Plugins[key].Loaded();
        } else if (typeof plugin === 'function') {
            Crustulum.Plugins[key] = plugin;
            Crustulum.Plugins[key]();
        }
    });
}

// Alternatively, you can set CrustulumInit to false to prevent the Init and set up your plugins after loading the script, remember to call `Crustulum.Init()` afterwards.
if (typeof CrustulumInit === 'undefined' || CrustulumInit) Crustulum.Init();

/* cSpell:ignore Crustulum, Toggleables, prefs, minigame, Mult, grimoire, grimoire's, grimoire\'s, Cyclius, dragonflight, Achiev, jscolor */
// ==UserScript==
// @name         Cookie Clicker Helper
// @namespace    http://tampermonkey.net/
// @version      1.9_02
// @description  free cookies
// @author       petar105
// @match        https://orteil.dashnet.org/cookieclicker/
// @icon         https://www.google.com/s2/favicons?domain=dashnet.org
// @grant        none
// ==/UserScript==

// If editing the script, ignore any "Game is not defined" warnings
(function() {
    'use strict';

    setInterval(function() { Game.ClickCookie(); }, 4);

setInterval(function() {
    Game.shimmers.forEach(function(shimmer)
    {
        if(shimmer.type == "golden" && shimmer.wrath == 0)
        {
            shimmer.pop()
        }
    })
}, 500);

var autoReindeer = setInterval(function() { for (var h in Game.shimmers){if(Game.shimmers[h].type=="reindeer"){Game.shimmers[h].pop();}} }, 100);

})();

var autoPopTwelveth = setInterval(function() {
    var wrinkCount = 0,
        wrinkEaten = 0,
        wrinkIndex = 10; // value for 10 shinies test

    for (var i in Game.wrinklers) {
        // count number of eating wrinks
        if (Game.wrinklers[i].sucked > 0) {
            wrinkCount += 1;
        }
        // find top wrink index, ignoring shiny wrinklers
        if (Game.wrinklers[i].sucked > wrinkEaten && Game.wrinklers[i].type == 0) {
            wrinkEaten = Game.wrinklers[i].sucked;
            wrinkIndex = i;
        }
    }
    // pop top wrinkler if 10 eating, unless all 12 are shiny
    if (wrinkCount == 10 && wrinkIndex != 10) {
        Game.wrinklers[wrinkIndex].hp = 0;
    }
}, 60000);


const moduleName = 'cookieGardenHelper';

const capitalize = (word) => word.charAt(0).toUpperCase() + word.slice(1);
const uncapitalize = (word) => word.charAt(0).toLowerCase() + word.slice(1);
const clone = (x) => JSON.parse(JSON.stringify(x));
const doc = {
  elId: document.getElementById.bind(document),
  qSel: document.querySelector.bind(document),
  qSelAll: document.querySelectorAll.bind(document),
}

class Config {
  static get default() {
    return {
      autoHarvest: false,
      autoHarvestNewSeeds: true,
      autoHarvestAvoidImmortals: true,
      autoHarvestWeeds: true,
      autoHarvestCleanGarden: false,
      autoHarvestCheckCpSMult: false,
      autoHarvestMiniCpSMult: { value: 1, min: 0 },
      autoHarvestDying: true,
      autoHarvestDyingSeconds: 5,
      autoHarvestCheckCpSMultDying: false,
      autoHarvestMiniCpSMultDying: { value: 1, min: 0 },
      autoPlant: false,
      autoPlantCheckCpSMult: false,
      autoPlantMaxiCpSMult: { value: 0, min: 0 },
      savedPlot: [],
    };
  }

  static get storageKey() { return moduleName; }

  static load() {
    let config = window.localStorage.getItem(this.storageKey);
    if (!config) {
      this.save(this.default);
      return this.default;
    }
    return Object.assign(this.default, JSON.parse(config));
  }

  static save(config) {
    window.localStorage.setItem(this.storageKey, JSON.stringify(config));
  }
}

class Garden {
  static get minigame() { return Game.Objects['Farm'].minigame; }
  static get isActive() { return this.minigame !== undefined; }

  static get CpSMult() {
    var res = 1
    for (let key in Game.buffs) {
        if (typeof Game.buffs[key].multCpS != 'undefined') {
            res *= Game.buffs[key].multCpS;
        }
    }
    return res;
  }

  static get secondsBeforeNextTick() {
    return (this.minigame.nextStep-Date.now()) / 1000;
  }

  static get selectedSeed() { return this.minigame.seedSelected; }
  static set selectedSeed(seedId) { this.minigame.seedSelected = seedId; }

  static clonePlot() {
    let plot = clone(this.minigame.plot);
    for (let x=0; x<6; x++) {
      for (let y=0; y<6; y++) {
        let [seedId, age] = plot[x][y];
        let plant = this.getPlant(seedId);
        if (plant != undefined && !plant.plantable) {
          plot[x][y] = [0, 0];
        }
      }
    }
    return plot;
  }

  static getPlant(id) { return this.minigame.plantsById[id - 1]; }
  static getTile(x, y) {
    let tile = this.minigame.getTile(x, y);
    return { seedId: tile[0], age: tile[1] };
  }

  static getPlantStage(tile) {
    let plant = this.getPlant(tile.seedId);
    if (tile.age < plant.mature) {
      return 'young';
    } else {
      if ((tile.age + Math.ceil(plant.ageTick + plant.ageTickR)) < 100) {
        return 'mature';
      } else {
        return 'dying';
      }
    }
  }

  static tileIsEmpty(x, y) { return this.getTile(x, y).seedId == 0; }

  static plantSeed(seedId, x, y) {
    let plant = this.getPlant(seedId + 1);
    if (plant.plantable) {
      this.minigame.useTool(seedId, x, y);
    }
  }

  static forEachTile(callback) {
    for (let x=0; x<6; x++) {
      for (let y=0; y<6; y++) {
        if (this.minigame.isTileUnlocked(x, y)) {
          callback(x, y);
        }
      }
    }
  }

  static harvest(x, y) { this.minigame.harvest(x, y); }

  static fillGardenWithSelectedSeed() {
    if (this.selectedSeed > -1) {
      this.forEachTile((x, y) => {
        if (this.tileIsEmpty(x, y)) {
          this.plantSeed(this.selectedSeed, x, y);
        }
      });
    }
  }

  static handleYoung(config, plant, x, y) {
    if (plant.weed && config.autoHarvestWeeds) {
      this.harvest(x, y);
    }
    let [seedId, age] = config.savedPlot[y][x];
    seedId--;
    if (config.autoHarvestCleanGarden &&
        ((plant.unlocked && seedId == -1) ||
         (seedId > -1 && seedId != plant.id))
        ) {
      this.harvest(x, y);
    }
  }

  static handleMature(config, plant, x, y) {
    if (!plant.unlocked && config.autoHarvestNewSeeds) {
      this.harvest(x, y);
    } else if (config.autoHarvestCheckCpSMult &&
               this.CpSMult >= config.autoHarvestMiniCpSMult.value) {
      this.harvest(x, y);
    }
  }

  static handleDying(config, plant, x, y) {
    if (config.autoHarvestCheckCpSMultDying &&
        this.CpSMult >= config.autoHarvestMiniCpSMultDying.value) {
      this.harvest(x, y);
    } else if (config.autoHarvestDying &&
        this.secondsBeforeNextTick <= config.autoHarvestDyingSeconds) {
      this.harvest(x, y);
    }
  }

  static run(config) {
    this.forEachTile((x, y) => {
      if (config.autoHarvest && !this.tileIsEmpty(x, y)) {
        let tile = this.getTile(x, y);
        let plant = this.getPlant(tile.seedId);

        if (plant.immortal && config.autoHarvestAvoidImmortals) {
          // do nothing
        } else {
          let stage = this.getPlantStage(tile);
          switch (stage) {
            case 'young':
              this.handleYoung(config, plant, x, y);
              break;
            case 'mature':
              this.handleMature(config, plant, x, y);
              break;
            case 'dying':
              this.handleDying(config, plant, x, y);
              break;
            default:
              console.log(`Unexpected plant stage: ${stage}`);
          }
        }
      }

      if (config.autoPlant &&
          (!config.autoPlantCheckCpSMult ||
          this.CpSMult <= config.autoPlantMaxiCpSMult.value) &&
          this.tileIsEmpty(x, y) &&
          config.savedPlot.length > 0
        ) {
        let [seedId, age] = config.savedPlot[y][x];
        if (seedId > 0) {
          this.plantSeed(seedId - 1, x, y);
        }
      }
    });
  }
}

class UI {
  static makeId(id) { return moduleName + capitalize(id); }
  static get css() {
    return `
#game.onMenu #cookieGardenHelper {
  display: none;
}
#cookieGardenHelper {
  background: #000 url(img/darkNoise.jpg);
  display: none;
  padding: 1em;
  position: inherit;
}
#cookieGardenHelper.visible {
  display: block;
}
#cookieGardenHelperTools:after {
  content: "";
  display: table;
  clear: both;
}

.cookieGardenHelperPanel {
  float: left;
  width: 25%;
}
.cookieGardenHelperBigPanel {
  float: left;
  width: 50%;
}
.cookieGardenHelperSubPanel {
  float: left;
  width: 50%;
}

#autoHarvestPanel { color: wheat; }
#autoHarvestPanel a { color: wheat; }

#autoPlantPanel { color: lightgreen; }
#autoPlantPanel a { color: lightgreen; }

#autoHarvestPanel a:hover,
#autoPlantPanel a:hover { color: white; }

#cookieGardenHelperTitle {
  color: grey;
  font-size: 2em;
  font-style: italic;
  margin-bottom: 0.5em;
  margin-top: -0.5em;
  text-align: center;
}
#cookieGardenHelper h2 {
  font-size: 1.5em;
  line-height: 2em;
}
#cookieGardenHelper h3 {
  color: lightgrey;
  font-style: italic;
  line-height: 2em;
}
#cookieGardenHelper p {
  text-indent: 0;
}
#cookieGardenHelper input[type=number] {
  width: 3em;
}

#cookieGardenHelper a.toggleBtn:not(.off) .toggleBtnOff,
#cookieGardenHelper a.toggleBtn.off .toggleBtnOn {
  display: none;
}
#cookieGardenHelper span.labelWithState:not(.active) .labelStateActive,
#cookieGardenHelper span.labelWithState.active .labelStateNotActive {
  display: none;
}

#cookieGardenHelperTooltip {
  width: 300px;
}
#cookieGardenHelperTooltip .gardenTileRow {
  height: 48px;
}
#cookieGardenHelperTooltip .tile {
  border: 1px inset dimgrey;
  display: inline-block;
  height: 48px;
  width: 48px;
}
#cookieGardenHelperTooltip .gardenTileIcon {
  position: inherit;
}

#cookieGardenHelper .warning {
    padding: 1em;
    font-size: 1.5em;
    background-color: orange;
    color: white;
}
#cookieGardenHelper .warning .closeWarning {
    font-weight: bold;
    float: right;
    font-size: 2em;
    line-height: 0.25em;
    cursor: pointer;
    transition: 0.3s;
}
#cookieGardenHelper .warning .closeWarning:hover {
    color: black;
}
`;
  }

  static numberInput(name, text, title, options) {
    let id = this.makeId(name);
    return `
<input type="number" name="${name}" id="${id}" value="${options.value}" step=0.5
  ${options.min !== undefined ? `min="${options.min}"` : ''}
  ${options.max !== undefined ? `max="${options.max}"` : ''} />
<label for="${id}" title="${title}">${text}</label>`;
  }

  static button(name, text, title, toggle, active) {
    if (toggle) {
      return `<a class="toggleBtn option ${active ? '' : 'off'}" name="${name}"
                 id="${this.makeId(name)}" title="${title}">
        ${text}
        <span class="toggleBtnOn">ON</span>
        <span class="toggleBtnOff">OFF</span>
      </a>`;
    }
    return `<a class="btn option" name="${name}" id="${this.makeId(name)}"
      title="${title}">${text}</a>`;
  }

  static toggleButton(name) {
    let btn = doc.qSel(`#cookieGardenHelper a.toggleBtn[name=${name}]`);
    btn.classList.toggle('off');
  }

  static labelWithState(name, text, textActive, active) {
    return `<span name="${name}" id="${this.makeId(name)}"
                  class="labelWithState ${active ? 'active' : ''}"">
      <span class="labelStateActive">${textActive}</span>
      <span class="labelStateNotActive">${text}</span>
    </span>`;
  }

  static labelToggleState(name, active) {
    let label = doc.qSel(`#cookieGardenHelper span.labelWithState[name=${name}]`);
    label.classList.toggle('active', active);
  }

  static createWarning(msg) {
    doc.elId('row2').insertAdjacentHTML('beforebegin', `
<div id="cookieGardenHelper">
  <style>${this.css}</style>
  <div class="warning">
    <span class="closeWarning">&times;</span>
    ${msg}
  </div>
</div>`);
    doc.qSel('#cookieGardenHelper .closeWarning').onclick = (event) => {
      doc.elId('cookieGardenHelper').remove();
    };
  }

  static get readmeLink() { return 'https://github.com/yannprada/'
      + 'cookie-garden-helper/blob/master/README.md#how-it-works'; }

  static build(config) {
    doc.qSel('#row2 .productButtons').insertAdjacentHTML('beforeend', `
        <div id="cookieGardenHelperProductButton" class="productButton">
          Cookie Garden Helper
        </div>`);
    doc.elId('row2').insertAdjacentHTML('beforeend', `
<div id="cookieGardenHelper">
  <style>${this.css}</style>
  <a href="${this.readmeLink}"
    target="new">how it works</a>
  <div id="cookieGardenHelperTitle" class="title">Cookie Garden Helper</div>
  <div id="cookieGardenHelperTools">
    <div class="cookieGardenHelperBigPanel" id="autoHarvestPanel">
      <h2>
        Auto-harvest
        ${this.button('autoHarvest', '', '', true, config.autoHarvest)}
      </h2>
      <div class="cookieGardenHelperSubPanel">
        <h3>immortal</h3>
        <p>
          ${this.button(
            'autoHarvestAvoidImmortals', 'Avoid immortals',
            'Do not harvest immortal plants', true,
            config.autoHarvestAvoidImmortals
          )}
        </p>
      </div>
      <div class="cookieGardenHelperSubPanel">
        <h3>young</h3>
        <p>
          ${this.button(
            'autoHarvestWeeds', 'Remove weeds',
            'Remove weeds as soon as they appear', true,
            config.autoHarvestWeeds
          )}
        </p>
        <p>
          ${this.button(
            'autoHarvestCleanGarden', 'Clean Garden',
            'Only allow saved and unlocked seeds', true,
            config.autoHarvestCleanGarden
          )}
        </p>
      </div>
      <div class="cookieGardenHelperSubPanel">
        <h3>mature</h3>
        <p>
          ${this.button(
            'autoHarvestNewSeeds', 'New seeds',
            'Harvest new seeds as soon as they are mature', true,
            config.autoHarvestNewSeeds
          )}
        </p>
        <p>
          ${this.button(
            'autoHarvestCheckCpSMult', 'Check CpS mult',
            'Check the CpS multiplier before harvesting (see below)', true,
            config.autoHarvestCheckCpSMult
          )}
        </p>
        <p>
          ${this.numberInput(
            'autoHarvestMiniCpSMult', 'Mini CpS multiplier',
            'Minimum CpS multiplier for the auto-harvest to happen',
            config.autoHarvestMiniCpSMult
          )}
        </p>
      </div>
      <div class="cookieGardenHelperSubPanel">
        <h3>dying</h3>
        <p>
          ${this.button(
            'autoHarvestDying', 'Dying plants',
            `Harvest dying plants, ${config.autoHarvestDyingSeconds}s before `
            + `the new tick occurs`, true,
            config.autoHarvestDying
          )}
        </p>
        <p>
          ${this.button(
            'autoHarvestCheckCpSMultDying', 'Check CpS mult',
            'Check the CpS multiplier before harvesting (see below)', true,
            config.autoHarvestCheckCpSMultDying
          )}
        </p>
        <p>
          ${this.numberInput(
            'autoHarvestMiniCpSMultDying', 'Mini CpS multiplier',
            'Minimum CpS multiplier for the auto-harvest to happen',
            config.autoHarvestMiniCpSMultDying
          )}
        </p>
      </div>
    </div>
    <div class="cookieGardenHelperPanel" id="autoPlantPanel">
      <h2>
        Auto-plant
        ${this.button('autoPlant', '', '', true, config.autoPlant)}
      </h2>
      <p>
        ${this.button(
          'autoPlantCheckCpSMult', 'Check CpS mult',
          'Check the CpS multiplier before planting (see below)', true,
          config.autoPlantCheckCpSMult
        )}
      </p>
      <p>
        ${this.numberInput(
          'autoPlantMaxiCpSMult', 'Maxi CpS multiplier',
          'Maximum CpS multiplier for the auto-plant to happen',
          config.autoPlantMaxiCpSMult
        )}
      </p>
      <p>
        ${this.button('savePlot', 'Save plot',
          'Save the current plot; these seeds will be replanted later')}
        ${this.labelWithState('plotIsSaved', 'No saved plot', 'Plot saved',
          Boolean(config.savedPlot.length))}
      </p>
    </div>
    <div class="cookieGardenHelperPanel" id="manualToolsPanel">
      <h2>Manual tools</h2>
      <p>
        ${this.button('fillGardenWithSelectedSeed', 'Plant selected seed',
        'Plant the selected seed on all empty tiles')}
      </p>
    </div>
  </div>
</div>`);

    doc.elId('cookieGardenHelperProductButton').onclick = (event) => {
      doc.elId('cookieGardenHelper').classList.toggle('visible');
    };

    doc.qSelAll('#cookieGardenHelper input').forEach((input) => {
      input.onchange = (event) => {
        if (input.type == 'number') {
          let min = config[input.name].min;
          let max = config[input.name].max;
          if (min !== undefined && input.value < min) { input.value = min; }
          if (max !== undefined && input.value > max) { input.value = max; }
          Main.handleChange(input.name, input.value);
        }
      };
    });

    doc.qSelAll('#cookieGardenHelper a.toggleBtn').forEach((a) => {
      a.onclick = (event) => {
        Main.handleToggle(a.name);
      };
    });

    doc.qSelAll('#cookieGardenHelper a.btn').forEach((a) => {
      a.onclick = (event) => {
        Main.handleClick(a.name);
      };
    });

    doc.elId('cookieGardenHelperPlotIsSaved').onmouseout = (event) => {
      Main.handleMouseoutPlotIsSaved(this);
    }
    doc.elId('cookieGardenHelperPlotIsSaved').onmouseover = (event) => {
      Main.handleMouseoverPlotIsSaved(this);
    }
  }

  static getSeedIconY(seedId) {
    return Garden.getPlant(seedId).icon * -48;
  }

  static buildSavedPlot(savedPlot) {
    return `<div id="cookieGardenHelperTooltip">
      ${savedPlot.map((row) => `<div class="gardenTileRow">
        ${row.map((tile) => `<div class="tile">
          ${(tile[0] - 1) < 0 ? '' : `<div class="gardenTileIcon"
            style="background-position: 0 ${this.getSeedIconY(tile[0])}px;">
          </div>`}
        </div>`).join('')}
      </div>`).join('')}
    </div>`;
  }
}

class Main {
  static init() {
    this.timerInterval = 1000;
    this.config = Config.load();
    UI.build(this.config);

    // sacrifice garden
    let oldConvert = Garden.minigame.convert;
    Garden.minigame.convert = () => {
      this.config.savedPlot = [];
      UI.labelToggleState('plotIsSaved', false);
      this.handleToggle('autoHarvest');
      this.handleToggle('autoPlant');
      this.save();
      oldConvert();
    }

    this.start();
  }

  static start() {
    this.timerId = window.setInterval(
      () => Garden.run(this.config),
      this.timerInterval
    );
  }

  static stop() { window.clearInterval(this.timerId); }

  static save() { Config.save(this.config); }

  static handleChange(key, value) {
    if (this.config[key].value !== undefined) {
      this.config[key].value = value;
    } else {
      this.config[key] = value;
    }
    this.save();
  }

  static handleToggle(key) {
    this.config[key] = !this.config[key];
    this.save();
    UI.toggleButton(key);
  }

  static handleClick(key) {
    if (key == 'fillGardenWithSelectedSeed') {
      Garden.fillGardenWithSelectedSeed();
    } else if (key == 'savePlot') {
      this.config['savedPlot'] = Garden.clonePlot();
      UI.labelToggleState('plotIsSaved', true);
    }
    this.save();
  }

  static handleMouseoutPlotIsSaved(element) {
    Game.tooltip.shouldHide=1;
  }

  static handleMouseoverPlotIsSaved(element) {
    if (this.config.savedPlot.length > 0) {
      let content = UI.buildSavedPlot(this.config.savedPlot);
      Game.tooltip.draw(element, window.escape(content));
    }
  }
}

if (Garden.isActive) {
  Main.init();
} else {
  let msg = `You don't have a garden yet. This mod won't work without it!`;
  console.log(msg);
  UI.createWarning(msg);
}

javascript: (function () {
  Game.LoadMod("https://icehawk78.github.io/FrozenCookies/frozen_cookies.js");
})();
Game.OpenSesame();
Game.fps = 5000
